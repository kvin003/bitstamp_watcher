## Introduction

The `ticker` program manages a collection of concurrently executing "watcher" processes
that monitor real-time data feeds from the Web.  As the watcher processes are notified
of events from their data feed, they report these events to the `ticker` process,
which extracts desired information from these events and accumulates it into a
"data store".  For concreteness, and due to the existence of free, publicly available
real-time data feeds, we will focus on monitoring data from a cryptocurrency exchange.
In particular, Bitstamp ([www.bitstamp.net](https://www.bitstamp.net/websocket/v2/))
provides data feeds pertaining to buying and
selling of cryptocurrencies on their exchange.  These data feeds are
available via a "Websocket" interface.  Websockets provide a means of bidirectional
interaction with Web server, which is currently increasing in popularity.

A Websocket connection is obtained by "upgrading" an ordinary HTTP or HTTPS connection
to a web server.  Fortunately, for the purposes of this assignment you do not need
to understand how this happens, or to know very much about Websockets or even ordinary
HTTP or HTTPS connections to Web servers.  This is because we will use a stand-alone
client program called `uwsc` (Ulfius WebSocket Client), running in a child process,
to actually make the Websocket connections.  For this assignment, I have made a
custom-compiled version of the `uwsc` program that is available on GitHub
([github.com](https://github.com/babelouest/ulfius.git)).

You can run the `uwsc` program from the Linux command line to make a Websocket
connection to a server.  For example, if you run:

```
$ uwsc wss://ws.bitstamp.net
```

you should see:

```
Websocket connected, you can send text messages of maximum 256 characters.
To exit uwsc, type !q<enter>
> 
```

The `>` is the command prompt from `uwsc`.  In order to cause the bitstamp server
to send some data, you need to subscribe to a "channel".  This is done by sending
a command (encoded in JSON) to the server.  For example:

```
> { "event": "bts:subscribe", "data": { "channel": "live_orders_btcusd" } }
```

You should then see "events" being reported (also encoded in JSON):

```
Send '{ "event": "bts:subscribe", "data": { "channel": "live_orders_btcusd" } }'
Server message: '{"event":"bts:subscription_succeeded","channel":"live_orders_btcusd","data":{}}'
Server message: '{"data":{"id":1599036464488448,"id_str":"1599036464488448","order_type":1,"datetime":"1679224736","microtimestamp":"1679224736496000","amount":0.22771886,"amount_str":"0.22771886","price":27106,"price_str":"27106"},"channel":"live_orders_btcusd","event":"order_created"}'
Server message: '{"data":{"id":1599036464488448,"id_str":"1599036464488448","order_type":1,"datetime":"1679224737","microtimestamp":"1679224736513000","amount":0.22771886,"amount_str":"0.22771886","price":27106,"price_str":"27106"},"channel":"live_orders_btcusd","event":"order_deleted"}'
Server message: '{"data":{"id":1599036464660480,"id_str":"1599036464660480","order_type":1,"datetime":"1679224737","microtimestamp":"1679224736537000","amount":0.00168139,"amount_str":"0.00168139","price":27174,"price_str":"27174"},"channel":"live_orders_btcusd","event":"order_created"}'
Server message: '{"data":{"id":1599036464726016,"id_str":"1599036464726016","order_type":1,"datetime":"1679224737","microtimestamp":"1679224736553000","amount":0.22771886,"amount_str":"0.22771886","price":27106,"price_str":"27106"},"channel":"live_orders_btcusd","event":"order_created"}'
...
```

The actual JSON responses from the server appear in between the single quotes (`'`)
in the above.  The `Send '...'` and `Server message: '...'` wrappers are generated by
`uwsc`; they will need to be removed by the program you write.
A line of the form `Send '...'` is used by `uwsc` to report JSON that is sent to
the server, whereas a line of the form `Server message: '...'` reports a JSON
response sent by the server.  

The `live_orders_btcusd` channel used above to illustrate the use of `uwsc` is
(from our point of view) a fairly high-rate data feed that produces on average
multiple events per second.  A feed like this will provide a good test of the
asynchronous signal-handling capabilities of your `ticker` program, but for development
purposes a lower-rate feed will be more useful.
Good examples are `live_trades_btcusd` and `live_trades_btcgbp`.
Your `ticker` program will use the events provided by the various `live_trades_xxx`
channels to accumulate information about cryptocurrency trades.

Besides Bitstamp, another site that provides a free real-time data feed via
Websockets is "blockchain.com"
[www.blockchain.com](https://www.blockchain.com/explorer/api/api_websocket).
This site, to which `uwsc` is also able to connect, provides real-time data about
updates to the Bitcoin blockchain.
Although it also uses JSON as the language for bidirectional communication between
the client and server, the format of the commands and responses is different
from Bitstamp's, so somewhat different "driver" code would be required to make
use of a feed from this site.
The architecture of the `ticker` program is designed to be general enough to support
multiple sites with different communication requirements, but you are only required
to implement support for the Bitstamp site in this assignment.

When `ticker` is launched, it presents a command-line interface:

```
$ bin/ticker
ticker> 
```

The command-line interface provides commands to start and stop watchers,
display a table of currently active watchers, enable or disable tracing
of events arriving from individual watchers, to show the data value
currently associated with a specified "key" in the data store, and to
perform a graceful shutdown of the main process and any executing watcher
processes.

So that waiting for the user to enter a command does not hinder the ability of
`ticker` to monitor external data feeds in real time, input from the command line
is treated just as if it were an additional data feed on which data can arrive
asynchronously.  In the context of the `ticker` architecture, this is done by
providing a `CLI` driver that understands how to interact with the user,
in addition to drivers that understand how to interact with a Websocket connection.

Here is an example of the use of the `ticker` command-line interface:

```
$ bin/ticker
ticker> watchers
0	CLI(-1,0,1)
```

There is initially just one "watcher" of type `CLI` (command-line interface),
which is not running in a separate process (the process ID is indicated as -1),
which is reading from standard input (file descriptor 0) and writing to standard
output (file descriptor 1).

```
ticker> start bitstamp.net live_trades_btcusd
ticker> watchers
0	CLI(-1,0,1)
1	bitstamp.net(404756,3,6) uwsc wss://ws.bitstamp.net [live_trades_btcusd]
```

Now there is an additional watcher, of type `bitstamp.net`,
which is running in process 404756, from which we can read data on file descriptor 3,
to which we can write data on file descriptor 6, and subscribed to channel `live_trades_btcusd`.

```
ticker> start bitstamp.net live_trades_btcgbp
ticker> watchers
0	CLI(-1,0,1)
1	bitstamp.net(404756,3,6) uwsc wss://ws.bitstamp.net [live_trades_btcusd]
2	bitstamp.net(404765,4,8) uwsc wss://ws.bitstamp.net [live_trades_btcgbp]
```

Now there is an additional watcher, of type `bitstamp.net`,
which is running in process 404765, with read file descriptor 4,
write file descriptor 8, and subscribed to channel `live_trades_btcgbp`.

```
ticker> trace 1
ticker> [1679233551.535374][bitstamp.net][ 3][   35]: Server message: '{"data":{"id":277351788,"timestamp":"1679233551","amount":0.00082,"amount_str":"0.00082000","price":27256,"price_str":"27256","type":0,"microtimestamp":"1679233551474000","buy_order_id":1599072570642432,"sell_order_id":1599072570363904},"channel":"live_trades_btcusd","event":"trade"}'

[1679233556.626918][bitstamp.net][ 3][   36]: Server message: '{"data":{"id":277351790,"timestamp":"1679233556","amount":0.002,"amount_str":"0.00200000","price":27253,"price_str":"27253","type":0,"microtimestamp":"1679233556564000","buy_order_id":1599072591491072,"sell_order_id":1599072580296705},"channel":"live_trades_btcusd","event":"trade"}'

```

Here we turned on tracing for "watcher #1".
While tracing was on, two events arrived.
At the beginning of each tracing line is shown:

* a timestamp (*e.g.* `[1679233551.535374]`), giving seconds and microseconds since the "Unix epoch"
  of midnight, January 1, 1970, UTC.

* the type `[bitstamp.net]` of the watcher.

* the file descriptor (*e.g. `[ 3]`) which `ticker` is using to read from this particular watcher.

* the serial number (*e.g.* `[   35]`) of the message received from this particular watcher;
  that is, this is the 35th message received from this watcher since it was started.

Following the initial information is the line of data that was read from the watcher
shown verbatim.

```
untrace 1
```

Tracing is turned off for watcher #1.

```
ticker> stop 1
```

Watcher #1 is terminated.

```
ticker> watchers
0	CLI(-1,0,1)
2	bitstamp.net(401983,7,10) uwsc wss://ws.bitstamp.net [live_trades_btcgbp]
```

Now only the CLI and watcher #2 are left.  Watcher ID 1 is free
to be used for a new watcher.

```
ticker> show bitstamp.net:live_trades_btcusd:price
bitstamp.net:live_trades_btcusd:price	27256.000000
```

We request the last trade price for this currency pair (Bitcoin and USD),
and are told that it is USD \$27256 per 1 BTC.

```
ticker> show bitstamp.net:live_trades_btcusd:volume
bitstamp.net:live_trades_btcusd:volume	5.063207
```

We request the total volume of trades for this currency pair,
and are told that a total of 5.063207 BTC have been traded since we started
watching.

```
ticker> quit
ticker> $ 
```

We ask to quit the program.  The watcher processes are killed, the main
process waits for them to terminate, and then the main process itself
exits.

### Implementation Details

The `ticker` program makes extensive use of processes, signals, and handlers
to create and manage the watchers.  A number of system calls are involved in
this, most of which have been discussed at least briefly in lecture.
When a `bitstamp.net` watcher is started, the main `ticker` process
uses the `fork()` system call to create a child process for it.  So that the
main process can communicate with the child, two pipes are created: one that
redirects output from the main process to the standard input of the child process,
and one that redirects the standard output of the child process to the main process.
Creation of the pipe and setting up the redirection uses the
`pipe()`, `dup2()`, and `close()` system calls.
Once the child process has started, it uses the `execvp()` system call to
execute the `uwsc` program with argument `wss://ws.bitstamp.net`.

The main process then outputs a JSON-encoded command

```
{ "event": "bts:subscribe", "data": { "channel": "live_trades_btcusd" } }
```

as a single line of text over the pipe to the child process, which reads
this line from its standard input and forwards it over the Websocket connection
to the server.  The `uwsc` program that the child process prints an
acknowledgement

```
Send '{ "event": "bts:subscribe", "data": { "channel": "live_orders_btcusd" } }'
```

to its standard output and it is sent over the pipe to the main `ticker` process.
Later, the Web server sends the JSON

```
{"event":"bts:subscription_succeeded","channel":"live_orders_btcusd","data":{}}
```

to indicate that subscription to the channel was successful, and the `uwsc` program
wraps this in some additional text and outputs the following over the pipe to
the main `ticker` process:

```
Server message: '{"event":"bts:subscription_succeeded","channel":"live_orders_btcusd","data":{}}'
```

In the meantime, while the above is going on, the CLI watcher in the main process
concurrently outputs a new prompt for the user on its standard output,
which is printed on the terminal:

```
ticker>  
```

Note that the CLI watcher and the `bitstamp.net` watchers run concurrently and
asynchronously, so, for example, if tracing is enabled (see below),
the order in which the new CLI prompt appears relative to any tracing output
that is printed will be timing-dependent.

The main `ticker` process maintains a table of watchers that it manages.
The index of a watcher in the table serves as a "watcher ID" that is used to
name the watcher in various operations (*e.g.* `stop` or `trace`).
The CLI watcher always has watcher ID 0.  When a new watcher is created,
it is allocated the least unused watcher ID (*i.e.* it is allocated the
watcher table slot with the least index that is not already in use).
The watcher table maintains all relevant information about each watcher.
Exactly what all this information is something that you will have to work out,
but at least each entry of the watcher table will contain the process ID of
the watcher process, as well as the file descriptors that the main process
uses to communicate with the watcher process.

The main `ticker` process relies on the receipt of a `SIGCHLD` signal to
inform it that a watcher process has terminated.  As part of its initialization,
the main process will therefore need to set up a handler for `SIGCHLD` signals.
When such a signal is received, the main process will use the `waitpid()`
system call to determine which watcher processes have terminated, and to obtain
their process ID's so that it can be arranged to close file descriptors
and free slots in the watcher table, as well as to free any other memory or
resources that were associated with the watchers that have terminated.
Setting up the signal handlers should be done with the `sigaction()` system call.
It will be useful to set the `SA_SIGINFO` flag when the handler is set up.
This enables additional information (structure `siginfo_t`) to be passed to the handler,
including a code (field `si_code`) that provides additional information about the
reason for the signal and a field `si_fd` that indicates the file descriptor
that originated the signal (this is not used for `SIGCHLD`, but it is used
for the `SIGIO` signal which you will also need to handle).
For full information, you will have to read the man page for `sigaction()`
in section 2 of the Linux manual.

Because there can be multiple concurrently executing watchers,
each of which will be sending event information asynchronously to the main
main process, it is not possible for the main process to use "normal"
(synchronous, blocking) I/O to read this event information.
The default behavior of the Unix I/O `read()` system call is that it will
*block* (or suspend) the calling process if there is currently no data
to be read.  This is clearly not desirable for the `ticker` program because,
for example, if the main ticker process were to block awaiting input, say,
from the user, then it would be unable to process any event information
arriving over the network until the user enters a command.
Similarly, the main process cannot commit to reading from the pipe connected
to any particular watcher process, because it is not known when (if ever)
additional input will be available from that process.

In order to work around the limitations of normal synchronous, blocking I/O,
the `ticker` program will perform I/O in an *asynchronous* and *non-blocking*
fashion.  The "non-blocking" part means that when an attempt is made to read
input from a watcher, if no input is available then the `read()` system call
will return immediately (with an error return and `errno` set to `EWOULDBLOCK`),
as opposed to waiting for an indefinite period for input to become available.
The "asynchronous" part means that the `ticker` program will use signals and
handlers in order to become informed about when input from a watcher has
become available.  Although the desired functionality could be achieved using
only non-blocking I/O, without the associated use of asynchronous I/O
notification via signals it would be necessary for the main `ticker` process
to waste CPU time running continuously in a "polling loop" checking for input
from each watcher over and over again.  This waste of CPU time is highly
undesirable and your program should not work that way (expect that there will
be grading tests to check for this!).

The `ticker` program will enable asynchronous I/O notification by arranging
for a `SIGIO` signal to be sent when a file descriptor becomes
ready for input.  It will install a handler for `SIGIO` in order to arrange
for input to be read from file descriptors that have become ready.
Installation of the `SIGIO` handler should be done using `sigaction()`,
similarly to the way the `SIGCHLD` handler is installed.
To enable asynchronous I/O notification on a file descriptor,
three things need to be done:
(1) Asynchronous I/O notification needs to be set on the file descriptor,
using the `fcntl()` system call with command `F_SETFL` and argument
`O_ASYNC`;
(2) The `fcntl()` system call has to be used on that file descriptor with
command `F_SETOWN` to identity the process to which I/O notifications for
that file descriptor should be sent;
(3) The `fcntl()` system call has to be used
on that file descriptor with command `F_SETSIG` to designate
`SIGIO` as the signal to be sent as the asynchronous I/O notification.
This third step is necessary for the `SA_SIGINFO` flag set on the signal handler
to cause the `si_fd` field of the `siginfo_t` structure to be populated
with the file descriptor that originated the `SIGIO`.

Note that `fcntl()` system call is also what is used to set non-blocking I/O
on a file descriptor; this is done using command `F_SETFL` with argument
`O_NONBLOCK`.

Once the signal handlers have been installed and the appropriate modes
set on the file descriptors, the normal operation of the `ticker` program
is to execute in a "main loop" in which there is a call to `sigsuspend()`.
The `sigsuspend()` system call temporarily unmasks signals that it is
desired to receive, and then suspends execution of the calling process until
one such signal has in fact been received.  This suspension of execution is
what avoids the continuous consumption of CPU cycles in polling file
descriptors to determine if they are ready for I/O.  Once a signal has
been received, the `sigsuspend()` system call returns and then the body
of the main loop performs any actions (such as reading from file descriptors
or handling termination of child processes) that are required.
Input is read from file descriptors until an error return with `errno`
set to `EWOULDBLOCK` is observed, at which point it is known
that all the available input has been consumed.  Once all input has been
consumed and processed, control returns to `sigsuspend()` and execution is
suspended again until the next signal is received.

### Watcher Types

`Ticker` has been designed using an architecture that makes it possible to
use the same mechanism for performing asynchronous, non-blocking I/O for
user input as is used for watcher processes.  In addition, the architecture
makes it to support "drivers" for multiple kinds of network data feeds,
though for this assignment you only need to worry about access to Bitstamp
using the `uwsc` Websocket client.

The way `ticker` supports multiple "drivers" is using the notion of a
*watcher type*.  The header file `ticker.h` defines type
`struct watcher_type` as follows:

```c
typedef struct watcher_type {
    char *name;
    char **argv;
    struct watcher *(*start)(struct watcher_type *type, char *args[]);
    int (*stop)(WATCHER *wp);
    int (*send)(WATCHER *wp, void *msg);
    int (*recv)(WATCHER *wp, char *txt);
    int (*trace)(WATCHER *wp, int enable);
} WATCHER_TYPE;
```

Each instance of the `watcher_type` structure defines something roughly
analogous to what a "class" would be used for in an object-oriented language.
The field `name` is a "class variable" that gives the name of the watcher type.
The field `argv` provides the name of an executable (in `argv[0]`) and additional
arguments to pass to that executable via `execvp()`.
The remaining fields are pointers to "methods".
There is a `start` method, which is in essence a constructor for initializing
an instance of the watcher type.
The `stop` method is used to terminate a previously constructed instance.
The `send` method is used to output a command or other information to the watcher
instance.
The `recv` method is used to input asynchronous data from the watcher and act on it.
Finally the `trace` method is used to enable or disable tracing of asynchronous
messages received from the watcher instance.

The file `watchers.c` contains an entry for each of the watcher types that are
configured into `ticker`.  In the basecode, there are only two such watcher types:
`CLI` and `bitstamp.net`, and these are the ones you are responsible for implementing.

The is no predetermined fixed size for the watcher type table.  Instead, the end
of the table is signalled by an entry whose fields are all set to 0.

To create an instance of a particular watcher type (*e.g.* in response to a CLI
`start` command) the watcher type has to first be looked up by name in the
`watcher_types` table.
Then, the `start` method of the watcher type has to be invoked, passing
as a parameter a pointer to the watcher type itself as the `type` argument,
and possibly passing a pointer to an additional vector of arguments as `args`
(any such arguments are above and beyond the fixed arguments given in the
`argv` field of the watcher type).
For example, the `bitstamp.net` watcher type will expect `args[0]` to contain a string
that specifies the name of a channel (*e.g.* `live_trades_btcusd`) to connect to,
once `uwsc` has been started and the Websocket connection has been made.
The `CLI` watcher type does not expect any additional arguments, and `NULL`
may be passed.

Once a watcher instance has been started using `start`, the other methods
may be used to operate on the instance.  Each method requires that a pointer
of type `WATCHER *` (aka `struct watcher *`) be passed; this corresponds to the
implicit parameter `this` in object-oriented languages.  The actual format of
`struct watcher` is unspecified; it is up to you to define it.  For the command-line
interface, you must also implement some way for a `WATCHER` to be looked up by
its index in the table of watcher instances.  How this is done depends on how
you choose to represent this table.

The `msg` argument to `send` can be a pointer to any type of value or even `NULL`,
depending on the needs of a particular watcher type.  For example, for the `CLI`
watcher type this will be a prompt to be shown to the user.  For the `bitstamp.net`
watcher type this could be a textual or other representation of a JSON command
to be sent to the server.

The `txt` argument to `recv` is a line of text received from the watcher instance.
For example, for the `CLI` watcher type this will be a command line typed by the user.
For the `bitstamp.net` watcher type this will be a line of text received from
the watcher process running `uwsc`.

The `enable` argument to `trace` is a boolean value that determines whether
tracing is to be enabled (nonzero) or disabled (zero).

You are required to manipulate watcher instances only by calling the specific
methods provided by the watcher type.  In particular, you may not introduce
any other functions that "do things to" watcher instances.  This is because
during grading we might decide to track calls to watcher methods to get some
idea of what your program is doing.
However, the interface between the watcher methods and the rest of `ticker`
is not specified, so within the implementation of the specified watcher methods
you may assume that you have have arbitrary access to any other part of the state
of `ticker`.

### The Data Store

For accumulating event information provided by watchers, I have provided a
binary implementation of a rudimentary "data store", which implements a simple
key/value mapping.  The interface of the data store is given in `store.h`.
The `store_put()` function is used to introduce a new key/value mapping
in the store, or to delete or replace the value already associated with a
given key.
The `store_get()` function is used to retrieve a value previously associated
with a key.  The value returned by `store_get()` is a heap-allocated value,
which it is the caller's responsibility to free using `store_free_value()`
when it is no longer required.

### The 'Argo' Parser

Communication between Websocket clients and servers typically uses JSON to
encode represent requests and responses.  Information about JSON syntax
can be found at [www.json.org](https://www.json.org/json-en.html).
So that you can focus on the central issues of this assignment, which are
processes and signal handling, I have provided (in binary form) a JSON parser
for you to use.  This parser, called `argo`, was written by me in the context
of an assignment given in this course in a previous semester.

The interface of the `argo` parser is given in the header file `argo.h`.
The code defines a type `ARGO_VALUE`, which is the data type used to represent
a JSON expression.  The functions provided for creating an `ARGO_VALUE` object is:

* `ARGO_VALUE *argo_read_value(FILE *f)`:
   This function parses JSON code read from an input stream and produces an
   `ARGO_VALUE` object that represents the parsed JSON expression.

The following function can be used to convert an `ARGO_VALUE` object back
to JSON form:

* `int argo_write_value(ARGO_VALUE *vp, FILE *f, int pretty)`:
   This function unparses an `ARGO_VALUE` object and emits JSON code
   to an output stream, possibly with "pretty-printing" applied to make
   the result more human-readable.

Since `ARGO_VALUE` objects are data structures allocated from the heap,
there needs to be a way to free them:

* `void argo_free_value(ARGO_VALUE *vp)`:
  This function is used to dispose of an `ARGO_VALUE` that is no longer
  required.

The details of the `ARGO_VALUE` data structure are not exposed.
However, there are several functions provided for "deconstructing"
an `ARGO_VALUE` object to determine its structure and extract the
information that it contains.  See the `argo.h` header file for
more details about these.

### The `CLI` Watcher Type

When started, the command-line interface watcher shall print a prompt
for the user to the standard output.  The prompt shall be exactly of
the form `ticker>`, followed by a single space and *without* any newline.
After printing the prompt, the command-line interface watcher shall
read a line of of input typed by the user, attempt to interpret it
as a command, and execute it.  Any output required to be produced
as a result of successfully executing the command shall be printed to the
standard output as complete lines of text, followed by a prompt for the
next user command.
Should parsing or execution of a command result in an error,
then `???` shall be printed to the standard output, followed by
a single newline and then a prompt for the next user command.

The structure of a command line is a sequence of "words",
which consist of non-whitespace chararacters, delimited by sequences
of whitespace characters.  The first word is the name of a command
to be executed; the remaining words are arguments to the command.

The following commands and arguments shall be supported:

* `quit` - Terminate the `ticker` program gracefully, *after* first
  terminating any active watchers and waiting for the associated
  child processes to terminate.  Note that simply calling `exit()`
  does not count as "graceful termination" of the `ticker` program.

* `watchers` - Print a list of the active watchers to the standard output,
  one per line, using the *exact* format shown in the examples above:

    ```
    0	CLI(-1,0,1)
    1	bitstamp.net(404756,3,6) uwsc wss://ws.bitstamp.net [live_trades_btcusd]
    2	bitstamp.net(404765,4,8) uwsc wss://ws.bitstamp.net [live_trades_btcgbp]
	```

  The first field is the `watcher ID`, which is the index of the
  watcher in the watcher table.  The watchers should be listed in increasing
  order of watcher ID, as shown.
  Following the watcher ID is a single TAB (`'\t'`) character.
  Following that is the name of the watcher type for the watcher, taken directly
  from the `name` field of the `WATCHER_TYPE` structure that defines
  that watcher type.
  Following the watcher type name are three numbers enclosed in parentheses
  and separated by commas as shown.  The first number is the process ID of the
  child process that is executing the watcher, if any, otherwise -1.
  The second number is the file descriptor being used by the main `ticker` process
  to read input from the watcher.
  The third number is the file descriptor being used by the main `ticker` process
  to write output to the watcher.
  Following the parenthesized numbers is a single space (`' '`) character.
  After the space comes the sequence of arguments from the `argv[]` vector,
  taken directly from the `WATCHER_TYPE` structure and separated from
  each other by a single space character.
  Finally, there is a single space, followed by the sequence of strings
  from the `args[]` additional arguments vector that was provided when the
  watcher instance was created.  These strings are also separated by a single
  space character, and the whole seqence is enclosed in square brackets:
  (`'['` and `']'`).

* `start` - This command takes at least one argument, which is the name of
  a watcher type for which an instance is to be started.  There may be
  additional arguments, which are provided as the `args[]` argument to
  the `start` method for the watcher type.  The effect of this command is
  to start an instance of the specified watcher type.  The new watcher
  shall be assigned the least watcher ID that is not already in use.

* `stop` - This command takes a single argument, which is the watcher ID
  of a watcher to be stopped.  The specified watcher is marked as "terminated",
  and any associated child process is sent a `SIGTERM` signal to request it to
  terminate.  The watcher will remain in the watcher table until it has been
  verified that the child process has actually terminated, at which point
  its watcher ID will become available for use by a subsequently started
  watcher instance.

  Note: an attempt to stop the `CLI` watcher instance shall be an error.

* `trace` - This command takes a single argument, which is the watcher number
  of a watcher instance to be traced.  The effect of the command is to enable
  tracing for that watcher.  Tracing a watcher means that each line of input received
  from that watcher is printed to the *standard error* output, in *exactly*
  the format shown in the examples above:
  
    ```
    [1679233551.535374][bitstamp.net][ 3][   35]: Server message: '{"data":{"id":277351788,"timestamp":"1679233551","amount":0.00082,"amount_str":"0.00082000","price":27256,"price_str":"27256","type":0,"microtimestamp":"1679233551474000","buy_order_id":1599072570642432,"sell_order_id":1599072570363904},"channel":"live_trades_btcusd","event":"trade"}'

    ```

    The first item in the output is a timestamp (enclosed in square brackets)
	representing the current date and time,
	as obtained by calling the function `clock_gettime()` with the `CLOCK_REALTIME`
	option.  The time is printed in the form `seconds.microseconds`, where `seconds`
	is the value of the `tv_sec` field of the `struct timespec` returned from
	`clock_gettime()` and `microseconds` is the value of the `tv_nsec` field of
	the `struct timespec` field, divided by 1000.  The microseconds field should
	be exactly six spaces in width, the value should be right-justified within the
	field and it should be padded on the left with leading zeros in case the value
	would otherwise not have six digits.

	The second item (also enclosed in square brackets) is the name of the watcher
	type for the particular watcher instance that is producing the trace output.

	The third item (also enclosed in square brackets) is the file descriptor
	being used by the `ticker` program to read input from the particular watcher
	instance that is producing the trace output.

	The fourth item (also enclosed in square brackets) is the serial number of
	the line of input for which the trace output is being generated.  The first
	line of input received by a watcher instance after being started shall have
	serial number 1, the second line shall have serial number 2, and so on.

	Following the preceding items shall be a single colon (`':'`) character,
	followed by a single space.  The remainder of the line shall consist of the
	line of data input from the watcher, exactly as it was received by the
	main `ticker` process.

* `untrace` - This command takes a single argument, which is the watcher number
	of a watcher instance to be untraced.  The effect of the command is to disable
	tracing for that watcher instance.

* `show` - This command takes a single argument, which is a key to be looked up
    in the data store.  If the store currently contains a value associated with
	that key, then the value is displayed in a single line printed to standard output,
	in the following format:
	
	```
    bitstamp.net:live_trades_btcusd:price	27256.000000
	```

	The first field of the output is the key.  This is followed by a TAB
	character (`'\t'`) and then the value associated with the key.
    If the store does not contain any value associated with the specified key,
	it shall be an error.

### The `bitstamp.net` Watcher Type

For the `bitstamp.net` watcher type, you are to provide implementations for
each of the watcher methods.  When started (using the `start()` method),
the watcher shall create a child process to run the `uwsc` program to manage
the Websocket connection to the server.  The `recv` method shall examine each
line of txt it is passed, to determine whether it has the form
`Server message: '...'`.  If so, then an attempt shall be made to interpret the
text occurring between the single quotes as JSON code.  If parsing of this code
is successful, then the result shall be examined to determine if it is a
JSON "object" having a field named `event` with value `trade`.
If so, then the value of the `price` and `amount` fields shall be extracted
and used to update the data store in the following way.
The value of the key `bitstamp.net:live_trades_XXXYYY:price` shall be updated
to the value of the `price` field in the received event.
Here `XXXYYY` is the 6-character string (such as `btcusd`) that represents the
currency pair being watched.
The value of the key `bitstamp.net:live_trades_XXXYYY:volume` shall be updated
to be the sum of its previous value (or 0.0 if this is the first update)
and the value of the `amount` field in the received event.
